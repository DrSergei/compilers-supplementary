-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binop (l, op, r) { 
  Binop (op, l, r)
}

-- Primary expression
var primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                          lident  @ fun (x) {Var (x)} |
                          inbr (s ("("), exp, s (")"))),
      exp = memo $ eta expr (
          {
            [Left, {[s ("!!"), binop]}],
            [Left, {[s ("&&"), binop]}],
            [Nona, {[s ("=="), binop], 
                    [s ("!="), binop], 
                    [s (">"), binop], 
                    [s ("<"), binop], 
                    [s (">="), binop], 
                    [s ("<="), binop]}],
            [Left, {[s ("+"), binop], 
                    [s ("-"), binop]}],
            [Left, {[s ("*"), binop], 
                    [s ("/"), binop], 
                    [s ("%"), binop]}]
          }, primary);

var elseStmt = memo $ eta syntax (
  kFi {Skip} |
  kElse t=stmt kFi {t} |
  kElif c=exp kThen t=stmt e=elseStmt {If (c, t, e)}
);
 
var unitStmt = memo $ eta syntax (
  kRead x=inbr[s("("), lident, s(")")] {Read (x)} |
  kWrite e=inbr[s("("), exp, s(")")] {Write (e)} |
  kSkip {Skip} |
  kIf c=exp kThen t=stmt e=elseStmt {If (c, t, e)} |
  kWhile c=exp kDo b=stmt kOd {While (c, b)} |
  kDo b=stmt kWhile c=exp kOd {DoWhile (b, c)} |
  kFor i=stmt s[","] c=exp s[","] s=stmt kDo b=stmt kOd {Seq (i, While (c, Seq (b, s)))} |
  x=lident s[":="] e=exp { Assn (x, e) }
);

var stmt = memo $ eta syntax (
  unitStmt |
  head=unitStmt s[";"] tail=stmt {Seq (head, tail)}
);
   

-- Public top-level parser
public parse = stmt;
